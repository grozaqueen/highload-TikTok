# TikTok
## 1. Тема и целевая аудитория
TikTok - сервис коротких видео
### MVP
* Регистрация и авторизация
* Публикация видео
* Просмотр видео в ленте
* Взаимодействие между пользователями посредством подписок
* Фидбек к видео через лайки, реакции, комментарии
* Рекомендации
* Поиск
### Целевая аудитория
По состоянию на 2024 год:

- **Ежемесячная аудитория (MAU):** 1,69 миллиарда пользователей.
- **DAU:** 600 млн.
- **Среднее время, проводимое пользователями в приложении:** 58 минут в день. 

**Аудитория:**

- **Возрастное распределение:**
  69,4% аудитории TikTok составляют пользователи в возрасте от 18 до 34 лет.

- **Гендерное распределение:** 50,8% пользователей — мужчины, 49,2% — женщины.

- **Географическое распределение:**
По состоянию на 2024 год, TikTok имеет следующую аудиторию по странам:

| №  | Страна             | Количество пользователей |
|:---|:-------------------|:-------------------------|
| 1  | Индонезия          | 157 млн                  |
| 2  | США                | 120 млн                  |
| 3  | Бразилия           | 105 млн                  |
| 4  | Мексика            | 77 млн                   |
| 5  | Россия             | 56 млн                   |
### Ключевые решения
* Бесконечная лента видео
* Реакции на видео
* Добавление видео в закладки
* Односторонние/двусторонние подписки

## 2. Расчет нагрузки

- **Ежемесячная аудитория (MAU):** 1,69 миллиарда пользователей.
- **DAU:** 600 млн.
- **Среднее время, проводимое пользователями в приложении:** 58 минут в день.
- **Средняя длина видео - 15 секунд, средний размер - 5 МБ**
- **34 млн видео ежедневно публикуются пользователями**
- **С ноября 2021 по январь 2022 года в TikTok зарегистрировалось более 58 млн пользователей**
- **В среднем на 10 просмотров видео приходится 1 лайк**

### 1. Продуктовые метрики

| Метрика | Значение |
|---------|----------|
| Месячная аудитория (MAU) | 1,69 млрд пользователей |
| Дневная аудитория (DAU) | 600 млн пользователей |
| Средний размер хранилища пользователя (видео) | 34 млн видео / 600 млн DAU = 0,057 видео на пользователя в день, 1,71 видео в месяц или около 143 видео за 7 лет|
| Средний размер хранилища пользователя (ГБ) | 0,057 видео * 5 МБ = 0,285 МБ в день на пользователя, 8,55 МБ в месяц * 12 * 7 лет = 718,2 МБ = 7,182 ГБ |

Из источников известно - 58 млн пользователей - прирост за 3 месяца - 8,55 МБ * 12 = 102,6 МБ на одного пользователя за год. 58 000 000 * 4 * 102 МБ = 23664 TB - прирост хранилища за год

#### Среднее количество действий пользователя в день 
| Действие | Значение |
|---------|----------|
| Просмотры видео | 58 минут в среднем в сутки * 60 / 15 секунд средняя длина видео = 232 просмотра в сутки |
| Публикация видео | 34 млн видео / 600 млн DAU = 0,057 видео на пользователя в день |
| Поиск | 1% от просмотров = 2 в сутки |
| Лайки | 10% от просмотров = 23 в сутки |
| Комментарии | оценим как 1% от просмотров = 2 в сутки |
| Подписки | оценим как 0,1% от просмотров = 0,2 в сутки |
| Авторизация | 58 млн (прирост за 3 месяца) /3 месяца/30 дней = 650 тысяч в сутки |

### 2. Технические метрики

#### Размер хранения данных

| Тип данных | Средний размер единицы данных | Количество данных | Размер данных |
|------------|-----------------|----------------|----------------|
| Опубликованные видео | 5 МБ 15 сек. видео | 34 млн в день | 4,7 ПБ в месяц |
| Комментарии | около 2 КБ на 1 комментарий | 2 * 30 * 1,69 млрд в месяц | 89 ТБ в месяц |

Пусть комментарий занимает около 2 кб, мы знаем, что около 2 комментариев оставляет пользователь в сутки => около 60 в месяц, а активных пользователей в месяц 1,69 млрд.

### Сетевой трафик

| Тип трафика | Пиковое потребление (Тбит/с) | Суточный объем |
|------------|-----------------|----------------|
| Просмотр видео | 95,03 | 5 МБ - средний размер видео, 232 просмотра за одним пользователем в день, 600 млн - DAU => 600 * 232 = 139,2 млрд просмотров в день => 696 ПБ/день |
| Публикация видео | 0,0369 | 5 МБ - средний размер видео, 34 млн в день публикуют = 162 ТБ/день |
| Лайки, комментарии | 0,00425 | 13,9 млрд в день * 1 КБ + 1,39 млрд в день * 2 КБ = 16.68 ТБ/день |
| Регистрация | 0,00148 | 650 тысяч в день * пусть 10 КБ на вход = 6,5 ТБ/день |
| Поиск | 0.2574 | 1,39 млрд в день * 2 МБ  = 2780 ТБ/день |

### RPS (Запросы в секунду)

| Тип запроса | RPS | пиковое RPS | 
|------------|------------|------------|
| Просмотр видео | 232 * 600 млн DAU /24/60/60 = 1611111 | 2416666 |
| Публикация видео | 0,057 видео в день публикует пользователь * 600 млн DAU /24/60/60 = 396 | 594 |
| Лайки, реакции | 13,9 млрд /24/60/60 = 161111 | 241666 |
| Комментарии | 1,39 млрд /24/60/60 = 16111 | 24166 |
| Поиск | 1,39 млрд /24/60/60 = 16111 | 24166 |
| Регистрация | 650 тысяч /24/60/60 = 8 | 12 |
| Авторизация | 9 | 13 |
| Бесконечная лента | 5 * 600 млн DAU /24/60/60 = 34722| 52083 |
| Суммарно | 1900000 | 2800000 |

## 3. Глобальная балансировка нагрузки

### Функциональное разбиение по доменам

* tiktok.com – основной домен

### Обоснования расположения ДЦ

TikTok имеет широкую аудиторию по всему миру, и для обеспечения эффективной работы сервиса можно расположить дата-центры охватив все части света, ориентируясь на страны с наибольшим числом пользователей. Для Азии это будет Индонезия с 157,6 миллионами пользователей и Филиппины (56,1 миллиона), для Северной Америки — США (120,5 миллиона) и Мексика (77,5 миллионов), для Южной Америки — Бразилия (105,3 миллиона), для Европы — Россия (56,0 миллиона), а для Африки — Нигерия и Египет. Также стоит учесть пользователей Таиланда (50,8 миллиона) и Бангладеша (41,1 миллиона), Пакистана (62,1 миллиона).

![image](https://github.com/user-attachments/assets/afe84979-ba6b-4f0b-9536-77df13ba7ffb)

| Регион | Города расположения ДЦ | Обоснование | 
|------------|------------|------------|
| Северная Америка | Нью-Йорк, Лос-Анджелес, Сиэтл, Мехико | Нью-Йорк будет обслуживать северо-восток США, Лос-Анжелес - юго-запад США, Сиэтл - и США, и Канаду, Мехико - Мексику |
| Южная Америка | Манаус, Бразилиа, Монтевидео | Манаус обслуживает север Южной Америки, Монтевидео - юг, Бразилиа - центр |
| Европа и Россия | Москва, Париж, Стокгольм, Новосибирск | Москва обслуживает Россию и Восточную часть Европы, Париж - запад Европы, Стокгольм - Скандинавию, Новосибирск для Сибири и Дальнего Востока |
| Азия | Исламабад, Бангкок, Джакарта, Дакка, Манила, Ханой, Токио | Исламабад обслуживает Пакистан и Непал, Бангкок — Таиланд и Малайзию и Камбоджу, Джакарта — Индонезию и Малайзию, Дакка — Бангладеш и соседние регионы Южной Азии, Манила — Филиппины и Малайзию, Ханой - Вьетнам, Токио - Японию |
| Африка | Каир, Абуджа | Каир обслуживает Северную Африку, Абуджа — Южную Африку |

### Расчет распределения запросов из секции "Расчет нагрузки" по типам запросов по датацентрам

Определим распределение запросов по разным регионам, исходя из следующих пропорций (MAU регионов / общее MAU):

* Северная Америка - 23%
* Южная Америка - 15%
* Россия и Европа - 17%
* Азия - 40%
* Африка - 5%

| Регион | Общий RPS | RPS на 1 ДЦ | 
|------------|------------|------------|
| Северная Америка | 475000 | 109250 - 5,75% |
| Южная Америка | 285000 | 95000 - 5% |
| Европа и Россия | 342000 | 85500 - 4,5% |
| Азия | 760000 | 108571 - 5,7% |
| Африка | 95000 | 47500 - 2,5% |

### Схема DNS балансировки
На основе определенного местоположения пользователя (страна, регион, континент) Geo-DNS выбирает наиболее подходящий датацентр или группу датацентров, которые находятся географически ближе всего.

### Схема Anycast балансировки
После того как Geo-DNS определяет ближайший датацентр, BGP Anycast берет на себя задачу сетевой маршрутизации, чтобы направить трафик к наилучшему маршруту через сеть, оптимизируя задержки и снижая нагрузку на другие датацентры (например, путем изменения метрик bgp используя Least Response Time алгоритм). 

## 4. Локальная балансировка нагрузки

### Cхемы балансировки для входящих и межсервисных запросов
* Virtual Server via Direct Routing (DR). Запрос отправляется на виртуальный IP-адрес (VIP) балансировщика. Балансировщик выбирает один из Nginx-серверов и заменяет MAC-адрес получателя в Ethernet-кадре на MAC-адрес выбранного Nginx-сервера.
* Nginx-сервер обрабатывает запрос и отправляет ответ напрямую клиенту, минуя балансировщик.
* Балансировка на уровне Nginx: Nginx как HTTP Reverse Proxy. Nginx принимает запросы от балансировщика. Балансирует нагрузку между бэкендами с помощью алгоритма Least Connections.

### Cхема отказоустойчивости
Service Discovery Kubernetes постоянно мониторит состояние подов с помощью проб, тем самым автоматизирует процесс регистрации, обновления реестра. В зависимости от прохождения проб, Kubernetes может перезапустить, создать новые контейнеры. Kubernetes автоматически масштабирует количество подов в зависимости от нагрузки.

### Нагрузка по терминации SSL
Используем session tickets для уменьшения количества полных обменов ключами, что снижает нагрузку на CPU. В среднем 4,7% запросов направляется на один дц, при этом в регионе работает 4 дц в среднем. При пиковом трафике 2,8 млн RPS на 1 дц приходится 131k RPS. С учетом Session Tickets, 60% запросов обходят полноценное SSL-рукопожатие, а 40% (53000 RPS) требуют 2 round-trip'а. При средней задержке 2 мс: 2 мс × 53000 = 105 секунд процессорного времени в секунду на один дц. 

## 5. Логическая схема БД
![image](https://github.com/user-attachments/assets/46cf9288-921d-41c7-9d8e-2a8cd2dd0ee7)

## 6. Физическая схема БД
![image](https://github.com/user-attachments/assets/a6d1ef8d-e5c9-4eb7-84cd-3028a503516d)

| Таблица | СУБД | Индексы  | Шардирование | Резервирование |
|------------|------------|------------|------------|------------|
| sessions | Redis | - | - | - |
| user | Apache Cassandra | username | по user_id | реплики |
| video | Apache Cassandra |  | по user_id | реплики |
| comment | Apache Cassandra | video_id | по videoId | реплики |
| subscriptions | Apache Cassandra | user_id | по user_id | реплики |
| subscribers | Apache Cassandra | user_id | по user_id | реплики |
| video_for_search | Elastic Search | id, description, user_id | встроенное | snapshots |
| user_for_search | Elastic Search | id, description, username | встроенное | snapshots |
| videoParameters | СlickHouse | video_id | по video_id | мастер-репликация |
| commentParameters | СlickHouse | comment_id | по comment_id | мастер-репликация |
| subscribersParameters | СlickHouse | subscriber_id | по subscriber_id | мастер-репликация |
| events | Kafka | - |  |  |
| userActions | Apache Cassandra | user_id | по user_id | реплики |
| itemActions | Postgres | contentId | по сreated_at | мастер-репликация |
| video_storage_s3 | amazon S3 |  |  | Бэкапы |
| image_storage_s3 | amazon S3 |  |  | Бэкапы |

## 7. Алгоритмы

### **Поиск**  

### **1. Этап лексико-синтаксического поиска**  

#### **Шаг 1. Текстовый поиск**  
1. **Токенизация и нормализация запроса**  
   - Разбиваем запрос на слова.  
   - Приводим к базовой форме.
   - Текст дополнительно разбивается на последовательности символов (биграммы, триграммы и т. д.)  

2. **Поиск документов с полученными словами**  
   При запросе ElasticSearch проверяет
   - Точные совпадения (полное слово)
   - Частичные совпадения (через n-граммы)

#### **Шаг 2. Векторный поиск**  
**Поиск ближайших соседей**  

HNSW (Hierarchical Navigable Small World) — это алгоритм для быстрого приближенного поиска ближайших соседей (Approximate Nearest Neighbors, ANN) в векторном пространстве
HNSW строит многослойный граф, где:
Нижние слои (Layer 0) содержат все векторы.
Верхние слои (Layer 1, 2, ...) содержат подмножество векторов, образующих "хабы" для быстрого поиска.
Чем выше слой, тем меньше в нем вершин, и тем быстрее можно найти путь к ближайшим соседям.

Перед построением HNSW-графа:
  * Каждый документ/запрос преобразуется в вектор (например, через Sentence-BERT).
  * Векторы нормализуются (часто используют L2-нормализацию для косинусной близости).

Поиск начинается с верхнего уровня и переход к соседям осуществляется на основании косинусного расстояния между векторами

Такой поиск позволяет найти синонимы

Если видео без какого-либо описания:
#### Компьютерное зрение: CLIP (Contrastive Language–Image Pretraining)
---
  CLIP — это модель, которая **сопоставляет изображения и текст в одном векторном пространстве**. Она не подписывает картинки словами напрямую, а просто оценивает, насколько описание подходит.  
  
  #### **Обработка данных**  
  
  - **Изображение**:
    - Ресайзится до `224x224` пикселей.  
    - Делится на кусочки (`32x32` пикселя) → превращается в числа (векторы `768D`).  
    - Добавляется информация о положении этих кусочков.  
  
  - **Текст**:
    - Разбивается на токены (слова или их части).  
    - Каждому токену сопоставляется вектор (`512D`).  
    - Добавляется информация о порядке слов.  
  
  Берем **N** пар (изображение + текст), кодируем их в векторы и сравниваем:  
  
  1. Вычисляем **косинусное сходство** между всеми картинками и текстами.  
  2. Учим модель максимизировать сходство **правильных** пар и минимизировать **ошибочные**.  
  3. Используем **контрастную функцию потерь**, которая регулирует обучение.  
  
  #### **Как работает CLIP на практике?**  
  
  1. Кодируем изображение и текст в векторы.  
  2. Считаем их косинусное сходство.  
  3. Чем ближе к `1`, тем лучше они подходят друг другу.  
  
  ---
  
  Whisper — это **seq2seq** (последовательность в последовательность) модель. Она берет **30-секундные куски аудио** и **генерирует текст**, предсказывая слово за словом.  
  
  1. Аудиофайл **преобразуется в спектрограмму** (картинку, где по вертикали — частоты, по горизонтали — время).  
  2. Пропускаем её через **кодировщик (Encoder)** → получаем сжатое представление звука.  
  
  1. **Декодер (Decoder)** предсказывает текст по частям:  
     - Сначала получает `[SOS]` (начало фразы).  
     - Постепенно добавляет новые токены, используя информацию из аудио.  
     - Заканчивает генерацию при `[EOS]` (конец фразы).  
  
  2. **На каждом шаге модель "смотрит" на аудио**, решая, какой токен выбрать дальше.  

### **2. Этап ранжирования**  
---
#### **1. Основная идея**
BM25 (Best Matching 25) — это вероятностный алгоритм ранжирования документов в полнотекстовом поиске. Он улучшает классический TF-IDF, учитывая:
- **Частоту терминов** в документе (TF)
- **Редкость терминов** в коллекции (IDF)
- **Длину документов** (нормализация)

---

#### **2. Формула BM25**
![image](https://github.com/user-attachments/assets/ae14c1fb-99af-4ad8-b300-89add5c075ec)

#### **A. TF (Term Frequency)**
Мера важности термина **внутри документа**:

- **Как работает**:
  - Чем чаще термин встречается в документе, тем выше его вес.
  - Параметр k1 контролирует насыщение:
    - k1 = 0: полностью отключает влияние TF.
    - k1 к бесконечности: линейная зависимость от частоты.
  - Нормализация по длине документа b:
    - b = 0: игнорирует длину документа.
    - b = 1: строгая нормализация.

#### **B. IDF (Inverse Document Frequency)**
Мера важности термина **в коллекции**:
![image](https://github.com/user-attachments/assets/9843ed45-f28d-45c2-b69a-db47f51af68f)

**Смысл**:
- Редкие термины (низкое n(q_i)) получают высокий IDF.
- Частые термины (например, стоп-слова) имеют IDF ≈ 0.

#### **C. Нормализация по длине документа**
![image](https://github.com/user-attachments/assets/4222cefe-f9dd-46bc-8e65-d9e545675c31)

- Уменьшает вес терминов в **длинных документах** (где слова могут встречаться случайно).
- Увеличивает вес терминов в **коротких документах** (например, заголовках).

---

### **3. Этап ранжирования на основе интересов пользователя**  

#### **Использование модели LightGBM**

LightGBM (**Light Gradient Boosting Machine**) — это алгоритм градиентного бустинга, который строит ансамбль деревьев решений для предсказания целевой переменной. 

Градиентный бустинг строит **множество деревьев решений**, каждое из которых исправляет ошибки предыдущих. В отличие от случайного леса, где деревья обучаются независимо, в градиентном бустинге каждое следующее дерево **пытается минимизировать ошибку** предыдущих.  

В отличие от других алгоритмов бустинга, которые строят деревья **в ширину**, LightGBM строит их **в глубину**, что делает его быстрее и эффективнее.  

- **LightGBM строит деревья неравномерно**:  
  - Он **выбирает лист с наибольшей ошибкой** и делит его.  
  - Это приводит к **меньшему количеству разбиений**, но **лучшей точности**.  

LightGBM выбирает признаки для разбиения, используя **метрику уменьшения ошибки (Gain Function)**.  
Чем больше Gain, тем лучше разбиение.  

После того как модель обучилась, она использует построенные деревья для предсказаний.  

1. **Новое видео** проходит через все деревья.  
2. На каждом дереве оно **проходит по условиям разбиений**.  
3. **Каждый лист возвращает числовое значение** (вероятность, что видео понравится).  
4. Все предсказания **суммируются**, и получается итоговый Score.  
---

### **Рекомендации**  

### **ALS (Alternating Least Squares)**  

Алгоритм **ALS** — это метод **матричной факторизации**.  

Нужно преобразовать таблицу взаимодействий пользователя с видео в **разреженную матрицу** (где большинство значений — нули, так как пользователи взаимодействовали лишь с малой частью контента).  

- Строки = UserID  
- Столбцы = VideoID  
- Значения = Вес взаимодействия  

Не все действия одинаково важны. Например:  
- **Лайк** важнее, чем просмотр.  
- **Добавление в избранное** сильнее влияет на рекомендации.  

Присваиваем каждому действию **вес**:  
- Лайк = **3.0**  
- Комментарий = **4.0**  
- Добавление в избранное = **5.0**   и т. д.
  
Вес = like * 3  + comment * 4 + favourite * 5

Чтобы веса были в одном масштабе, применяем логарифмирование:  

Rnorm = log(1 + R)

Каждый пользователь и видео можно представить скрытыми (латентными) факторами размерности k 
Ищем **две матрицы**:  
- **`U`** (пользователи) размером `[n_users × k]`  
- **`V`** (видео) размером `[n_videos × k]`  

Так, чтобы:  R ~ U * V^T

### **3.2. Функция потерь (Loss Function)**  
Минимизируем:  

![image](https://github.com/user-attachments/assets/e65c5cb8-ac61-4b27-8842-ad26428a88c6)

где lambda — коэффициент регуляризации (обычно 0.01–0.1).  

---

1. Задаём размерность эмбеддингов `k` (например, 32).  
2. Заполняем `U` и `V` случайными малыми числами.  

#### Шаг 1: Оптимизация пользовательских эмбеддингов (`U`) 
Фиксируем `V` и обновляем `U`:  
1. Для каждого пользователя `i`:  
   - Собираем все видео `j`, с которыми он взаимодействовал.  
   - Решаем систему линейных уравнений:  
![image](https://github.com/user-attachments/assets/4cae88bb-b007-4363-8ec6-3101bb4c3598)

#### Шаг 2: Оптимизация эмбеддингов видео (`V`)
Фиксируем `U` и обновляем `V`:  
1. Для каждого видео `j`:  
   - Собираем всех пользователей `i`, которые с ним взаимодействовали.  
   - Решаем аналогичную систему

Повторяем шаги 1 и 2 **10–20 раз** до сходимости.  

---

Для пользователя `i` и видео `j`:  
![image](https://github.com/user-attachments/assets/d04a633b-0248-426d-956e-85943651f12d)


1. Для каждого пользователя вычисляем **score** для всех видео.  
2. Сортируем видео по убыванию `score`.  

### **Этап учета дополнительных факторов**  

Добавим к предсказаниям такие корректировки, как популярность видео (на основе таблиц действий к видео), свежесть видео (по дате его создания), отсортируем по убыванию итогового score

### **Этап рерэнкинга**  

Применим финальную перестановку элементов для улучшения ux

Уберем подряд идущие похожие видео
* Maximal Marginal Relevance (MMR) — это алгоритм для баланса между релевантностью и диверсификацией. Он предотвращает однообразие в выдаче, выбирая элементы, которые одновременно максимально релевантны запросу пользователя, минимально похожи на уже выбранные элементы.
* Для каждого кандидата i из оставшегося множества R вычисляется score:
![image](https://github.com/user-attachments/assets/fe443d37-84eb-4986-8e66-627c193e0e84)
![image](https://github.com/user-attachments/assets/05aa0a42-d5e3-4ae9-bf9a-a6d9bc711ca2)
На входе: список кандидатов R, пустой результат S =[], параметр λ.
Выбрать самый релевантный элемент из R (с максимальным ALS_score), добавить в S, удалить из R.

Итеративное пополнение:
* Пока S не достиг нужного размера:
* Для каждого i∈R вычислить MMR(i).
* Выбрать элемент с наибольшим MMR.
* Перенести его из R в S.
* Результат: Диверсифицированный список S.

## 8. Технологии
---

### **1. Балансировка и маршрутизация трафика**  

| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Amazon Route 53** | Глобальная балансировка | Перенаправляет пользователей на ближайший дата-центр на основе их геолокации (страна, регион). Уменьшает задержки за счёт выбора оптимального PoP (Point of Presence). |
| **Cloudflare** | Сетевая маршрутизация | Обеспечивает автоматическую маршрутизацию трафика к ближайшему серверу через Anycast-IP. Использует **Least Response Time** для минимизации задержек. |
| **Keepalived** | Балансировка L3 | Позволяет балансировать миллионы запросов в секунду с минимальными накладными расходами. Nginx-серверы отвечают клиенту напрямую, снижая нагрузку на балансировщик. |
| **Nginx** | Балансировка L7 (HTTP/HTTPS) | Распределяет запросы между бэкендами, поддерживает кэширование, gzip, SSL-терминацию. Алгоритм **Least Connections** минимизирует перегрузку серверов. |

---

### **2. Отказоустойчивость и Service Discovery**  

| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Kubernetes** | Оркестрация и масштабирование | Автоматически увеличивает/уменьшает количество подов на основе CPU/RPS. Поддерживает **Liveness/Readiness Probes** для самовосстановления. |
| **Prometheus + Alertmanager** | Мониторинг и алертинг | Собирает метрики с Kubernetes и сервисов, отправляет алерты при сбоях. |
| **Grafana**           | Визуализация метрик, мониторинг          | Визуализирует метрики из различных источников (например, Prometheus) в виде графиков и дашбордов, что помогает инженерам следить за состоянием системы, выявлять проблемы и отслеживать показатели производительности. |

---

### **3. SSL-терминация, безопасность**  

| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Nginx + Session Tickets** | Ускорение SSL/TLS | Уменьшает нагрузку на CPU за счёт **Session Resumption** (60% запросов не требуют полного handshake). |
| **HashiCorp Vault** | Основное хранилище (токены, API-ключи) | Средство для безопасного хранения и управления доступом к конфиденциальной информации, такой как пароли и API-ключи, предотвращает несанкционированный доступ и улучшает безопасность системы. |

---

### **4. Рекомендации, поиск, аналитика**  

| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Elasticsearch + Sentence-BERT** | Семантический поиск | Позволяет искать контент по смыслу (а не только по ключевым словам). |
| **CLIP** | Рекомендации видео | Сопоставляет видео и текстовые описания для улучшения рекомендаций. |
| **Whisper** | Транскрипция аудио | Автоматически генерирует субтитры для индексации и поиска. |
| **LightGBM** | Ранжирование | Используется для предсказания заинтересованности и персонализации ленты. |
| **Redis** | Ускорение ответа | Хранит предвычисленные рекомендации для быстрого доступа. |
| **apache Kafka** | Обработка событий | Фиксирует действия пользователей (лайки, просмотры) в реальном времени. |
| **Python, Numpy, Scipy**      |	Математические вычисления, ab-тесты |	NumPy предоставляет оптимизированные многомерные массивы и матричные операции с поддержкой SIMD-инструкций, что критически важно для быстрой обработки экспериментальных данных и статистических расчетов. SciPy расширяет эти возможности, добавляя специализированные модули для научных вычислений, включая продвинутую статистику, оптимизацию и анализ сигналов. Вместе эти библиотеки позволяют точно оценивать статистическую значимость результатов A/B-тестов, выполнять сложные математические преобразования и эффективно работать с большими массивами данных, что делает их незаменимыми инструментами для анализа метрик и принятия данных решений. |

---

### **5. Хранение и доставка контента**  

| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Amazon S3** | Хранение видео | Обеспечивает отказоустойчивость и быстрый доступ к медиа. |
| **CDN** | Доставка видео | Кэширует контент на edge-серверах, снижая задержки. |

---

### **6. Разработка**
| **Технология**       | **Область применения**               | **Обоснование** |
|----------------------|--------------------------------------|----------------|
| **Typescript**       | Фронтенд                                 | Статическая типизация поверх JavaScript обеспечивает раннее выявление ошибок, улучшает поддержку крупных проектов и упрощает рефакторинг. Позволяет создавать более надежный код с автодополнением и проверкой типов в IDE. |
| **Kotlin**            | Мобильное приложение Android             | Язык, используемый для разработки Android-приложений, предлагает лаконичний и безопасный синтаксис для создания приложений, поддерживает корутины для асинхронных операций, что делает его удобным для построения быстрореагирующих интерфейсов. |
| **Swift**             | Мобильное приложение iOS                 | Основной язык для разработки iOS-приложений. |
| **Golang**            | Бэкенд                                   | Простая конкурентная модель (горутины) обеспечивает высокую производительность при масштабировании. Статическая компиляция дает преимущества в скорости и развертывании. Идеален для микросервисов и высоконагруженных API. |
| **Fluentd**            | Сбор и агрегация логов                  | Сбор и агрегация логов |

---

## 9. Схема проекта
![image](https://github.com/user-attachments/assets/34e15331-ba11-4dfb-8d46-54637dc47b35)

## 10. Обеспечение надежности

### **1. Резервирование**  

| **Вид резервирования**               | **Описание**                                                                 | **Применение**                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| **Резервирование CDN и доставки видео** | Дублирование серверов и точек присутствия для быстрой загрузки видео        | Обеспечение плавного воспроизведения без задержек                              |
| **Резервирование обработки видео**      | Дублирование GPU-серверов для кодирования и оптимизации загруженных видео   | Предотвращение задержек при загрузке нового контента                           |
| **Резервирование рекомендательной системы** | Дублирование серверов, генерирующих персонализированную ленту              | Бесперебойная работа алгоритмов рекомендаций                                   |
| **Резервирование социальных функций**   | Дублирование серверов лайков, комментариев, подписок                       | Обеспечение стабильности взаимодействий между пользователями                   |
| **Резервирование модерации контента**   | Дублирование систем автоматической и ручной модерации                      | Непрерывная проверка загружаемых видео на соответствие политикам платформы     |
| **Резервирование аналитики**           | Дублирование систем сбора данных о просмотрах и поведении пользователей     | Гарантия сохранности статистики даже при сбоях                                 |

---

### **2. Сегментирование**  
- **Геораспределение**: Разделение серверов по регионам для ускорения доставки видео.  
- **Выделение групп серверов по функционалу (+учитывая сложнось функционала)**:  
  - Отдельные сервисы для рекомендаций, ленты, загрузки видео, комментариев, лайков.  
- **Безопасность и модерация**:  
  - Выделенные серверы для проверки контента (AI + ручная модерация).  
- **A/B-тестирование**:  
  - Изолированные окружения для тестирования новых алгоритмов рекомендаций.  
- **Платежи и реклама**:  
  - Отдельная инфраструктура для монетизации (чтобы не мешать основному функционалу).  
- **Тестовые и продакшн-окружения**:  
  - Полная изоляция, чтобы ошибки в тестах не влияли на пользователей.  

---

### **3. Failover Policy (Политика отказоустойчивости)**  

| **Компонент**                     | **Критичность** | **Действия при отказе**                                                                 | **Время реакции**       |
|-----------------------------------|----------------|----------------------------------------------------------------------------------------|-------------------------|
| **Доставка видео (CDN)**         | Критичный       | Автоматическое переключение на резервные серверы                                       | **Немедленно**          |
| **Рекомендательная система**      | Критичный       | Переход на упрощённый алгоритм (например, популярные видео вместо персонализации)      | **< 30 сек**            |
| **Лайки / комментарии**          | Важный          | Временное кэширование действий и отложенная синхронизация                             | **< 1 мин**             |
| **Аналитика просмотров**         | Некритичный     | Локальное сохранение данных с последующей выгрузкой при восстановлении                 | **< 1 час**             |

---

### **4. Graceful Shutdown (Плавное завершение работы)**  
1. **Уведомление пользователей** (если возможно):  
   - Пуш-уведомления о технических работах.  
2. **Остановка загрузки новых видео**:  
   - Новые загрузки временно приостанавливаются.  
3. **Сохранение прогресса**:  
   - Фиксация всех просмотров, лайков, комментариев.  
4. **Постепенное отключение сервисов**:  
   - Сначала аналитика → затем соц. функции → потом рекомендации → наконец, CDN.  
5. **Очистка ресурсов**:  
   - Освобождение GPU-серверов, закрытие соединений с CDN.  

---

### **5. Graceful Degradation (Ухудшение с сохранением работы)**  
1. **Упрощение рекомендаций**:  
   - Большая "учительская" модель обучает компактную "дистиллированную" модель (в 10-100 раз меньше). При нагрузке >95% CPU переключаем 50% трафика на slim-модель
   - Отключаем рерэнкинг Л2 для 30% пользователей
1. **Поиск**:
   - отключаем Л2 ранжирование для 30% пользователей
3. **Отложенная синхронизация соц. действий**:  
   - Лайки/комментарии - использовать примерное количество, хранящееся в метаданных для объекта (видео/комментария)
---

### **6. Асинхронные паттерны**  
1. **CQRS** (Command Query Responsibility Segregation):  
   - Разделение записи (загрузка видео) и чтения (просмотр ленты).  
2. **Event Sourcing**:  
   - Все действия (просмотры, лайки) фиксируются как события для аналитики.  
3. **Outbox Pattern**:  
   - Этот подход синхронизирует данные между разными базами через брокер сообщений: сначала информация пишется в основное хранилище, затем асинхронно реплицируется в поисковые и рекомендательные системы. Так TikTok обеспечивает мгновенную доступность новых видео в ленте и поиске, не нагружая основную БД.е).  

---

### **7. Observability (Мониторинг и логирование)**  
- **Logstash**:  
  - Сбор логов из всех сервисов (CDN, модерация, рекомендации).  
- **Elasticsearch**:  
  - Хранение и анализ данных о просмотрах, ошибках, производительности.  
- **Grafana**:  
  - Дашборды для мониторинга:  
    - Скорость загрузки видео по регионам.  
    - Эффективность рекомендаций.  
    - Задержки в социальных функциях.

## 11. Список серверов

### 1. Введение
Основные вводные данные:

* **MAU**: 1.69 млрд
* **DAU**: 600 млн
* **Пиковая нагрузка**: \~2.8 млн RPS
* **Глобальное покрытие**: 5 регионов

### Расчёт RPS

| Действие       |    RPS        |
| -------------- | ------------- |
| Просмотры      | 2,416,666     |
| Лайки          | 241,666       |
| Загрузка видео | 5000          |
| Рекомендации   | 52000         |
| **Итого**      | **\~2.8 млн** |

### 2. Kubernetes-инфраструктура

### 2.1 Параметры пода

Все микросервисы платформы реализованы на Go, что обеспечивает высокую производительность и эффективное использование ресурсов. По опыту эксплуатации Go-сервисов в продакшене (включая данные из Uber Engineering и Cloudflare), можно ориентироваться на следующие параметры:

Пропускная способность: до 500 RPS на под для сетевых I/O-ориентированных микросервисов (например, просмотры, лайки, рекомендации), при грамотной реализации и отсутствии тяжёлой бизнес-логики.

Ресурсы: в среднем достаточно 0.5 CPU и 0.5 ГБ RAM на под для таких сервисов.

* **500 RPS на под**
* **0.5 CPU и 0.5 ГБ RAM** на под

### 2.2 Кол-во подов

| Сервис         | RPS       | Поды  | CPU (ядра) | RAM (ГБ) |
| -------------- | --------- | ----- | ---------- | -------- |
| Лента          | 2,416,666 | 4,834 | 2,417      | 2,417    |
| Лайки/реакции  | 241,666   | 484   | 242        | 242      |
| Загрузка видео | 5,000     | 10    | 5          | 5        |
| Рекомендации   | 52,000    | 104   | 52         | 52       |
| **Итого**      | —         | 5,432 | 2,716      | 2,716    |

### 2.3 Расчёт серверов

**Конфигурация сервера**: 128 CPU, 512 ГБ RAM
**Эффективно доступно** (с учётом overhead):

* CPU: 128 × 0.85 = 108 ядер
* RAM: 512 × 0.9 = 460 ГБ

**Лимитирующий ресурс** — CPU:

* 108 / 0.5 = **216 подов/сервер**

Общее количество серверов:

* 5,432 / 216 ≈ 25
* +20% резерв: **30 серверов**

## 3. Stateful-сервисы

### 3.1 Cassandra (видео)
При конфигурации ноды 32 vCPU и 128 ГБ RAM, Cassandra может выдерживать:
от 30k до 60k RPS на чтения, поэтому пусть производительность одной ноды 50k RPS
* **Нагрузка**: 2.4 млн RPS чтений
* **Производительность одной ноды**: 50k RPS (32 CPU / 128 ГБ RAM)
* **Ноды без учёта репликации**: 2,400,000 / 50,000 = 48
* **С учётом RF=3**: 48 × 3 = **144**, округляем до **120** (баланс нагрузки, отказоустойчивость)

### 3.2 Elasticsearch (поиск и рекомендации)
При конфигурации ноды **64 vCPU и 256 ГБ RAM**, Elasticsearch может выдерживать от **50k до 100k RPS** на чтения, поэтому для расчёта берём **75k RPS** на одну ноду.
* **Нагрузка**: 1.5 млн RPS (поиск и рекомендации)
* **Производительность одной ноды**: 75k RPS (64 CPU / 256 ГБ RAM)
* **Ноды без учёта репликации**:
  1,500,000 / 75,000 = **20**
* **С учётом RF=3**:
  20 × 3 = **60**
  Округляем до **60** (баланс нагрузки, отказоустойчивость)
Итого: **60 нод**

### 3.3 Redis (кэш сессий и ленты)
При конфигурации ноды **16 vCPU и 64 ГБ RAM**, Redis может выдерживать от **200k до 400k RPS** на чтения и записи, поэтому для расчёта берём **300k RPS** на одну ноду.
* **Нагрузка**: 300k RPS (кэш сессий и ленты)
* **Производительность одной ноды**: 300k RPS (16 CPU / 64 ГБ RAM)
* **Ноды без учёта репликации**:
  300,000 / 300,000 = **1**
* **С учётом RF=2**:
  1 × 2 = **2**
  Округляем до **2** (баланс нагрузки, отказоустойчивость)
Итого: **2 ноды**

### 3.4 Kafka (очереди событий)
При конфигурации ноды **32 vCPU и 128 ГБ RAM**, Kafka может выдерживать от **50k до 100k RPS** на обработку сообщений, поэтому для расчёта берём **75k RPS** на одну ноду.
* **Нагрузка**: 3.75 млн RPS (очереди событий)
* **Производительность одной ноды**: 75k RPS (32 CPU / 128 ГБ RAM)
* **Ноды без учёта репликации**:
  3,750,000 / 75,000 = **50**
* **С учётом RF=3**:
  50 × 3 = **150**
  Округляем до **50** (баланс нагрузки, отказоустойчивость)
Итого: **50 нод**

### 3.5 ClickHouse (аналитика просмотров)
При конфигурации ноды **64 vCPU и 256 ГБ RAM**, ClickHouse может выдерживать от **100k до 200k RPS** на чтение, поэтому для расчёта берём **150k RPS** на одну ноду.
* **Нагрузка**: 1 млн RPS (аналитика просмотров)
* **Производительность одной ноды**: 150k RPS (64 CPU / 256 ГБ RAM)
* **Ноды без учёта репликации**:
  1,000,000 / 150,000 = **7**
* **С учётом RF=3**:
  7 × 3 = **21**
  Округляем до **20** (баланс нагрузки, отказоустойчивость)
Итого: **20 нод**

## 4. Балансировка нагрузки

### 4.1 CDN (видеоконтент)

* **Пиковый трафик**: 95 Тбит/с
* **Пропускная способность одного edge-сервера**: 200 Гбит/с
* **Серверов**: 95,000 / 200 = 475 → **480** (с запасом)

### 4.2 Nginx (балансировщики приложений)

* **Общая нагрузка**: 2.8 млн RPS
* **Один сервер**: 150 тыс. RPS
* **Количество**: 2,800,000 / 150,000 ≈ 19
* +20% резерв: **24 сервера**

## 5. Глобальная инфраструктура

### 5.1 Распределение трафика

| Регион           | Трафик | RPS   | Дата-центры            |
| ---------------- | ------ | ----- | ---------------------- |
| Азия             | 40%    | 1.12M | Джакарта, Токио        |
| Северная Америка | 23%    | 644K  | Нью-Йорк, Лос-Анджелес |
| Европа           | 17%    | 476K  | Франкфурт, Стокгольм   |

### 5.2 Задержки между ЦОД

| Путь                    | RTT   |
| ----------------------- | ----- |
| Токио ↔ Джакарта        | 82 мс |
| Нью-Йорк ↔ Лос-Анджелес | 68 мс |
| Франкфурт ↔ Стокгольм   | 28 мс |

## 6. Стоимость инфраструктуры (в месяц)

| Компонент         | Кол-во | Цена за ед. | Всего         |
| ----------------- | ------ | ----------- | ------------- |
| Kubernetes        | 30     | $500       | $15,000      |
| CDN edge          | 480    | $200       | $96,000      |
| Cassandra         | 120    | $500       | $60,000      |
| Redis             | 4      | $300       | $1,200       |
| Nginx LB          | 24     | $300       | $7,200       |
| **Итого / месяц** |        |             | **$179,400** |

---

## Источники
1. https://www.demandsage.com/tiktok-user-statistics
2. https://fliki.ai/blog/tiktok-video-size
3. https://techjury.net/blog/how-many-videos-are-uploaded-to-tiktok-daily/
4. https://ecommerce-platforms.com/ru/articles/tiktok-statistics
5. https://inclient.ru/tiktok-stats
6. https://domainator.by/schitaet-li-tiktok-vashi-sobstvennye-prosmotry
