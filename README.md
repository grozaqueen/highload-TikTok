# TikTok
## 1. Тема и целевая аудитория
TikTok - сервис коротких видео
### MVP
* Регистрация и авторизация
* Публикация видео
* Просмотр видео в ленте
* Взаимодействие между пользователями посредством подписок
* Фидбек к видео через лайки, реакции, комментарии
* Рекомендации
* Поиск
### Целевая аудитория
По состоянию на 2024 год:

- **Ежемесячная аудитория (MAU):** 1,69 миллиарда пользователей.
- **DAU:** 600 млн.
- **Среднее время, проводимое пользователями в приложении:** 58 минут в день. 

**Аудитория:**

- **Возрастное распределение:**
  69,4% аудитории TikTok составляют пользователи в возрасте от 18 до 34 лет.

- **Гендерное распределение:** 50,8% пользователей — мужчины, 49,2% — женщины.

- **Географическое распределение:**
По состоянию на 2024 год, TikTok имеет следующую аудиторию по странам:

| №  | Страна             | Количество пользователей |
|:---|:-------------------|:-------------------------|
| 1  | Индонезия          | 157 млн                  |
| 2  | США                | 120 млн                  |
| 3  | Бразилия           | 105 млн                  |
| 4  | Мексика            | 77 млн                   |
| 5  | Россия             | 56 млн                   |
### Ключевые решения
* Бесконечная лента видео
* Реакции на видео
* Добавление видео в закладки
* Односторонние/двусторонние подписки

## 2. Расчет нагрузки

- **Ежемесячная аудитория (MAU):** 1,69 миллиарда пользователей.
- **DAU:** 600 млн.
- **Среднее время, проводимое пользователями в приложении:** 58 минут в день.
- **Средняя длина видео - 15 секунд, средний размер - 5 МБ**
- **34 млн видео ежедневно публикуются пользователями**
- **С ноября 2021 по январь 2022 года в TikTok зарегистрировалось более 58 млн пользователей**
- **В среднем на 10 просмотров видео приходится 1 лайк**

### 1. Продуктовые метрики

| Метрика | Значение |
|---------|----------|
| Месячная аудитория (MAU) | 1,69 млрд пользователей |
| Дневная аудитория (DAU) | 600 млн пользователей |
| Средний размер хранилища пользователя (видео) | 34 млн видео / 600 млн DAU = 0,057 видео на пользователя в день, 1,71 видео в месяц или около 143 видео за 7 лет|
| Средний размер хранилища пользователя (ГБ) | 0,057 видео * 5 МБ = 0,285 МБ в день на пользователя, 8,55 МБ в месяц * 12 * 7 лет = 718,2 МБ = 7,182 ГБ |

Из источников известно - 58 млн пользователей - прирост за 3 месяца - 8,55 МБ * 12 = 102,6 МБ на одного пользователя за год. 58 000 000 * 4 * 102 МБ = 23664 TB - прирост хранилища за год

#### Среднее количество действий пользователя в день 
| Действие | Значение |
|---------|----------|
| Просмотры видео | 58 минут в среднем в сутки * 60 / 15 секунд средняя длина видео = 232 просмотра в сутки |
| Публикация видео | 34 млн видео / 600 млн DAU = 0,057 видео на пользователя в день |
| Поиск | 1% от просмотров = 2 в сутки |
| Лайки | 10% от просмотров = 23 в сутки |
| Комментарии | оценим как 1% от просмотров = 2 в сутки |
| Подписки | оценим как 0,1% от просмотров = 0,2 в сутки |
| Авторизация | 58 млн (прирост за 3 месяца) /3 месяца/30 дней = 650 тысяч в сутки |

### 2. Технические метрики

#### Размер хранения данных

| Тип данных | Средний размер единицы данных | Количество данных | Размер данных |
|------------|-----------------|----------------|----------------|
| Опубликованные видео | 5 МБ 15 сек. видео | 34 млн в день | 4,7 ПБ в месяц |
| Комментарии | около 2 КБ на 1 комментарий | 2 * 30 * 1,69 млрд в месяц | 89 ТБ в месяц |

Пусть комментарий занимает около 2 кб, мы знаем, что около 2 комментариев оставляет пользователь в сутки => около 60 в месяц, а активных пользователей в месяц 1,69 млрд.

### Сетевой трафик

| Тип трафика | Пиковое потребление (Тбит/с) | Суточный объем |
|------------|-----------------|----------------|
| Просмотр видео | 95,03 | 5 МБ - средний размер видео, 232 просмотра за одним пользователем в день, 600 млн - DAU => 600 * 232 = 139,2 млрд просмотров в день => 696 ПБ/день |
| Публикация видео | 0,0369 | 5 МБ - средний размер видео, 34 млн в день публикуют = 162 ТБ/день |
| Лайки, комментарии | 0,00425 | 13,9 млрд в день * 1 КБ + 1,39 млрд в день * 2 КБ = 16.68 ТБ/день |
| Регистрация | 0,00148 | 650 тысяч в день * пусть 10 КБ на вход = 6,5 ТБ/день |
| Поиск | 0.2574 | 1,39 млрд в день * 2 МБ  = 2780 ТБ/день |

### RPS (Запросы в секунду)

| Тип запроса | RPS | пиковое RPS | 
|------------|------------|------------|
| Просмотр видео | 232 * 600 млн DAU /24/60/60 = 1611111 | 2416666 |
| Публикация видео | 0,057 видео в день публикует пользователь * 600 млн DAU /24/60/60 = 396 | 594 |
| Лайки, реакции | 13,9 млрд /24/60/60 = 161111 | 241666 |
| Комментарии | 1,39 млрд /24/60/60 = 16111 | 24166 |
| Поиск | 1,39 млрд /24/60/60 = 16111 | 24166 |
| Регистрация | 650 тысяч /24/60/60 = 8 | 12 |
| Авторизация | 9 | 13 |
| Бесконечная лента | 5 * 600 млн DAU /24/60/60 = 34722| 52083 |
| Суммарно | 1900000 | 2800000 |

## 3. Глобальная балансировка нагрузки

### Функциональное разбиение по доменам

* tiktok.com – основной домен

### Обоснования расположения ДЦ

TikTok имеет широкую аудиторию по всему миру, и для обеспечения эффективной работы сервиса можно расположить дата-центры охватив все части света, ориентируясь на страны с наибольшим числом пользователей. Для Азии это будет Индонезия с 157,6 миллионами пользователей и Филиппины (56,1 миллиона), для Северной Америки — США (120,5 миллиона) и Мексика (77,5 миллионов), для Южной Америки — Бразилия (105,3 миллиона), для Европы — Россия (56,0 миллиона), а для Африки — Нигерия и Египет. Также стоит учесть пользователей Таиланда (50,8 миллиона) и Бангладеша (41,1 миллиона), Пакистана (62,1 миллиона).

![image](https://github.com/user-attachments/assets/afe84979-ba6b-4f0b-9536-77df13ba7ffb)

| Регион | Города расположения ДЦ | Обоснование | 
|------------|------------|------------|
| Северная Америка | Нью-Йорк, Лос-Анджелес, Сиэтл, Мехико | Нью-Йорк будет обслуживать северо-восток США, Лос-Анжелес - юго-запад США, Сиэтл - и США, и Канаду, Мехико - Мексику |
| Южная Америка | Манаус, Бразилиа, Монтевидео | Манаус обслуживает север Южной Америки, Монтевидео - юг, Бразилиа - центр |
| Европа и Россия | Москва, Париж, Стокгольм, Новосибирск | Москва обслуживает Россию и Восточную часть Европы, Париж - запад Европы, Стокгольм - Скандинавию, Новосибирск для Сибири и Дальнего Востока |
| Азия | Исламабад, Бангкок, Джакарта, Дакка, Манила, Ханой, Токио | Исламабад обслуживает Пакистан и Непал, Бангкок — Таиланд и Малайзию и Камбоджу, Джакарта — Индонезию и Малайзию, Дакка — Бангладеш и соседние регионы Южной Азии, Манила — Филиппины и Малайзию, Ханой - Вьетнам, Токио - Японию |
| Африка | Каир, Абуджа | Каир обслуживает Северную Африку, Абуджа — Южную Африку |

### Расчет распределения запросов из секции "Расчет нагрузки" по типам запросов по датацентрам

Определим распределение запросов по разным регионам, исходя из следующих пропорций (MAU регионов / общее MAU):

* Северная Америка - 23%
* Южная Америка - 15%
* Россия и Европа - 17%
* Азия - 40%
* Африка - 5%

| Регион | Общий RPS | RPS на 1 ДЦ | 
|------------|------------|------------|
| Северная Америка | 475000 | 109250 - 5,75% |
| Южная Америка | 285000 | 95000 - 5% |
| Европа и Россия | 342000 | 85500 - 4,5% |
| Азия | 760000 | 108571 - 5,7% |
| Африка | 95000 | 47500 - 2,5% |

### Схема DNS балансировки
На основе определенного местоположения пользователя (страна, регион, континент) Geo-DNS выбирает наиболее подходящий датацентр или группу датацентров, которые находятся географически ближе всего.

### Схема Anycast балансировки
После того как Geo-DNS определяет ближайший датацентр, BGP Anycast берет на себя задачу сетевой маршрутизации, чтобы направить трафик к наилучшему маршруту через сеть, оптимизируя задержки и снижая нагрузку на другие датацентры (например, путем изменения метрик bgp используя Least Response Time алгоритм). 

## 4. Локальная балансировка нагрузки

### Cхемы балансировки для входящих и межсервисных запросов
* Virtual Server via Direct Routing (DR). Запрос отправляется на виртуальный IP-адрес (VIP) балансировщика. Балансировщик выбирает один из Nginx-серверов и заменяет MAC-адрес получателя в Ethernet-кадре на MAC-адрес выбранного Nginx-сервера.
* Nginx-сервер обрабатывает запрос и отправляет ответ напрямую клиенту, минуя балансировщик.
* Балансировка на уровне Nginx: Nginx как HTTP Reverse Proxy. Nginx принимает запросы от балансировщика. Балансирует нагрузку между бэкендами с помощью алгоритма Least Connections.

### Cхема отказоустойчивости
Service Discovery Kubernetes постоянно мониторит состояние подов с помощью проб, тем самым автоматизирует процесс регистрации, обновления реестра. В зависимости от прохождения проб, Kubernetes может перезапустить, создать новые контейнеры. Kubernetes автоматически масштабирует количество подов в зависимости от нагрузки.

### Нагрузка по терминации SSL
Используем session tickets для уменьшения количества полных обменов ключами, что снижает нагрузку на CPU. В среднем 4,7% запросов направляется на один дц, при этом в регионе работает 4 дц в среднем. При пиковом трафике 2,8 млн RPS на 1 дц приходится 131k RPS. С учетом Session Tickets, 60% запросов обходят полноценное SSL-рукопожатие, а 40% (53000 RPS) требуют 2 round-trip'а. При средней задержке 2 мс: 2 мс × 53000 = 105 секунд процессорного времени в секунду на один дц. 

## 5. Логическая схема БД
![image](https://github.com/user-attachments/assets/46cf9288-921d-41c7-9d8e-2a8cd2dd0ee7)

## 6. Физическая схема БД
![image](https://github.com/user-attachments/assets/a6d1ef8d-e5c9-4eb7-84cd-3028a503516d)

| Таблица | СУБД | Индексы  | Шардирование | Резервирование |
|------------|------------|------------|------------|------------|
| sessions | Redis | - | - | - |
| user | Apache Cassandra | username | по user_id | реплики |
| video | Apache Cassandra |  | по user_id | реплики |
| comment | Apache Cassandra | video_id | по videoId | реплики |
| subscriptions | Apache Cassandra | user_id | по user_id | реплики |
| subscribers | Apache Cassandra | user_id | по user_id | реплики |
| video_for_search | Elastic Search | id, description, user_id | встроенное | snapshots |
| user_for_search | Elastic Search | id, description, username | встроенное | snapshots |
| videoParameters | СlickHouse | video_id | по video_id | мастер-репликация |
| commentParameters | СlickHouse | comment_id | по comment_id | мастер-репликация |
| subscribersParameters | СlickHouse | subscriber_id | по subscriber_id | мастер-репликация |
| events | Kafka | - |  |  |
| userActions | Apache Cassandra | user_id | по user_id | реплики |
| itemActions | Postgres | contentId | по сreated_at | мастер-репликация |
| video_storage_s3 | amazon S3 |  |  | Бэкапы |
| image_storage_s3 | amazon S3 |  |  | Бэкапы |

## 7. Алгоритмы

### **Поиск**  

### **1. Этап лексико-синтаксического поиска**  

#### **Шаг 1. Текстовый поиск**  
1. **Токенизация и нормализация запроса**  
   - Разбиваем запрос на слова.  
   - Приводим к базовой форме.
   - Текст дополнительно разбивается на последовательности символов (биграммы, триграммы и т. д.)  

2. **Поиск документов с полученными словами**  
   При запросе ElasticSearch проверяет
   - Точные совпадения (полное слово)
   - Частичные совпадения (через n-граммы)

#### **Шаг 2. Векторный поиск**  
**Поиск ближайших соседей**  

HNSW (Hierarchical Navigable Small World) — это алгоритм для быстрого приближенного поиска ближайших соседей (Approximate Nearest Neighbors, ANN) в векторном пространстве
HNSW строит многослойный граф, где:
Нижние слои (Layer 0) содержат все векторы.
Верхние слои (Layer 1, 2, ...) содержат подмножество векторов, образующих "хабы" для быстрого поиска.
Чем выше слой, тем меньше в нем вершин, и тем быстрее можно найти путь к ближайшим соседям.

Перед построением HNSW-графа:
  * Каждый документ/запрос преобразуется в вектор (например, через Sentence-BERT).
  * Векторы нормализуются (часто используют L2-нормализацию для косинусной близости).

Поиск начинается с верхнего уровня и переход к соседям осуществляется на основании косинусного расстояния между векторами

Такой поиск позволяет найти синонимы

Если видео без какого-либо описания:
#### Компьютерное зрение: CLIP (Contrastive Language–Image Pretraining)

  CLIP — это модель, которая **сопоставляет изображения и текст в одном векторном пространстве**. Она не подписывает картинки словами напрямую, а просто оценивает, насколько описание подходит.  
  
  #### **Обработка данных**  
  
  - **Изображение**:
    - Ресайзится до `224x224` пикселей.  
    - Делится на кусочки (`32x32` пикселя) → превращается в числа (векторы `768D`).  
    - Добавляется информация о положении этих кусочков.  
  
  - **Текст**:
    - Разбивается на токены (слова или их части).  
    - Каждому токену сопоставляется вектор (`512D`).  
    - Добавляется информация о порядке слов.  
  
  Берем **N** пар (изображение + текст), кодируем их в векторы и сравниваем:  
  
  1. Вычисляем **косинусное сходство** между всеми картинками и текстами.  
  2. Учим модель максимизировать сходство **правильных** пар и минимизировать **ошибочные**.  
  3. Используем **контрастную функцию потерь**, которая регулирует обучение.  
  
  #### **Как работает CLIP на практике?**  
  
  1. Кодируем изображение и текст в векторы.  
  2. Считаем их косинусное сходство.  
  3. Чем ближе к `1`, тем лучше они подходят друг другу.  
  
  ---
  
  Whisper — это **seq2seq** (последовательность в последовательность) модель. Она берет **30-секундные куски аудио** и **генерирует текст**, предсказывая слово за словом.  
  
  1. Аудиофайл **преобразуется в спектрограмму** (картинку, где по вертикали — частоты, по горизонтали — время).  
  2. Пропускаем её через **кодировщик (Encoder)** → получаем сжатое представление звука.  
  
  1. **Декодер (Decoder)** предсказывает текст по частям:  
     - Сначала получает `[SOS]` (начало фразы).  
     - Постепенно добавляет новые токены, используя информацию из аудио.  
     - Заканчивает генерацию при `[EOS]` (конец фразы).  
  
  2. **На каждом шаге модель "смотрит" на аудио**, решая, какой токен выбрать дальше.  

### **2. Этап ранжирования**  
---
#### **1. Основная идея**
BM25 (Best Matching 25) — это вероятностный алгоритм ранжирования документов в полнотекстовом поиске. Он улучшает классический TF-IDF, учитывая:
- **Частоту терминов** в документе (TF)
- **Редкость терминов** в коллекции (IDF)
- **Длину документов** (нормализация)

---

#### **2. Формула BM25**
![image](https://github.com/user-attachments/assets/ae14c1fb-99af-4ad8-b300-89add5c075ec)

#### **A. TF (Term Frequency)**
Мера важности термина **внутри документа**:

- **Как работает**:
  - Чем чаще термин встречается в документе, тем выше его вес.
  - Параметр k1 контролирует насыщение:
    - k1 = 0: полностью отключает влияние TF.
    - k1 к бесконечности: линейная зависимость от частоты.
  - Нормализация по длине документа b:
    - b = 0: игнорирует длину документа.
    - b = 1: строгая нормализация.

#### **B. IDF (Inverse Document Frequency)**
Мера важности термина **в коллекции**:
![image](https://github.com/user-attachments/assets/9843ed45-f28d-45c2-b69a-db47f51af68f)

**Смысл**:
- Редкие термины (низкое n(q_i)) получают высокий IDF.
- Частые термины (например, стоп-слова) имеют IDF ≈ 0.

#### **C. Нормализация по длине документа**
![image](https://github.com/user-attachments/assets/4222cefe-f9dd-46bc-8e65-d9e545675c31)

- Уменьшает вес терминов в **длинных документах** (где слова могут встречаться случайно).
- Увеличивает вес терминов в **коротких документах** (например, заголовках).

---

### **3. Этап ранжирования на основе интересов пользователя**  

#### **1. Формирование обучающих данных**

Данные о взаимодействиях пользователей с видео хранятся в PostgreSQL в таблице `userActions`. В ней записываются действия пользователей (`view`, `like`, `comment` и т. д.) с указанием времени события.

Теперь необходимо определить целевую переменную (что считать "интересом пользователя"). Мы будем использовать лайки или добавления в избранное как индикатор заинтересованности:

target = {
    1, если likes > 0 или favorites > 0
    0, иначе
}

---

#### **2. Обучение модели LightGBM**

Модель строит **деревья решений**, которые разделяют данные на группы, основываясь на значениях признаков. Например:

1. **Первое разбиение:** если прошло **много дней** с последнего взаимодействия, вероятность интереса ниже.
2. **Второе разбиение:** если у пользователя **много просмотров**, но **мало лайков**, видео не такое привлекательное.
3. **Третье разбиение:** если **много лайков или избранных**, видео точно интересно.

Каждое дерево добавляет новые предсказания, улучшая точность модели.

Финальная оценка релевантности видео рассчитывается как:

![image](https://github.com/user-attachments/assets/9202f222-d8c0-4655-b63a-e12418ace8f6)

Видео с **наибольшими значениями score** выводятся пользователю первыми.

---

## Источники
1. https://www.demandsage.com/tiktok-user-statistics
2. https://fliki.ai/blog/tiktok-video-size
3. https://techjury.net/blog/how-many-videos-are-uploaded-to-tiktok-daily/
4. https://ecommerce-platforms.com/ru/articles/tiktok-statistics
5. https://inclient.ru/tiktok-stats
6. https://domainator.by/schitaet-li-tiktok-vashi-sobstvennye-prosmotry
